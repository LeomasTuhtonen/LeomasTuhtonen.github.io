<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beam Calculator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background:#f4f4f4; color:#333; }
        #container { display:flex; flex-wrap:wrap; gap:20px; padding:20px; }
        #controls { flex:1 1 300px; max-width:400px; }
        #charts { flex:1 1 600px; display:grid; grid-template-columns:1fr 1fr; gap:20px; }
        #charts .section { min-width:0; }
        #charts .full-width { grid-column:1 / -1; }
        .section { background:#fff; padding:15px; border-radius:8px; box-shadow:0 2px 5px rgba(0,0,0,0.1); margin-bottom:20px; }
        .input-row { margin-bottom: 10px; }
        label { display: inline-block; width: 140px; }
        input[type='number'], select { width: 100px; padding:4px; }
        #sectionPropsTable { border-collapse: collapse; margin-top:4px; }
        #sectionPropsTable td, #sectionPropsTable th { border: 1px solid #ccc; padding:2px 4px; font-size:12px; }
        canvas { width: 100%; height: 250px; margin-top: 20px; background:#fff; border:1px solid #ddd; padding:10px; border-radius:4px; }
        button { padding:6px 12px; margin-top:4px; background:#4CAF50; color:white; border:none; border-radius:4px; cursor:pointer; }
        button:hover { background:#45a049; }
        .remove-btn { background:#f44336; }
        .remove-btn:hover { background:#d32f2f; }
        h1 { text-align:center; padding:20px 0; margin:0; background:#fff; box-shadow:0 2px 4px rgba(0,0,0,0.1); margin-bottom:20px; }
        #tabs { text-align:center; margin-bottom:20px; }
        #tabs button { padding:6px 12px; margin:0 5px; border:none; border-radius:4px; cursor:pointer; background:#ddd; }
        #tabs button.active { background:#4CAF50; color:white; }
        .tabcontent { display:none; }
    </style>
</head>
<body>
    <h1>Beam Calculator</h1>
    <div id="tabs">
        <button data-tab="analysis" class="active" onclick="showTab('analysis')">Analysis</button>
        <button data-tab="design" onclick="showTab('design')">Design</button>
    </div>
    <div id="analysisTab" class="tabcontent" style="display:block;">
    <div id="container">
    <div id="controls">
    <div class="section">
        <h2>Results</h2>
        <div class="input-row">
            <label>Show results for:</label>
            <select id="resultsSelect"></select>
            <button id="exportBtn">Export PDF</button>
        </div>
        <pre id="summaryOutput"></pre>
        <div id="warningMsg" style="color:red;font-weight:bold;"></div>
    </div>

    <div class="section">
        <h2>Beam Setup</h2>
        <div class="input-row">
            <label>Max node distance:</label>
            <input type="number" id="maxNodeDist" value="0.2" min="0.1" step="0.1" />
        </div>
        <div class="input-row">
            <label>Material:</label>
            <select id="materialSelect">
                <option value="steel" selected>Steel</option>
                <option value="timber">Timber</option>
            </select>
        </div>
        <div class="input-row">
            <label>Cross-section:</label>
            <select id="sectionSelect"></select>
        </div>
        <div class="input-row">
            <label></label>
            <table id="sectionPropsTable"></table>
        </div>
        <div class="input-row">
            <label>Include self weight:</label>
            <input type="checkbox" id="selfWeightToggle" checked />
        </div>
        <div class="input-row">
            <label>Left support present:</label>
            <input type="checkbox" id="leftSupportToggle" checked />
        </div>
        <div class="input-row">
            <label>Right support present:</label>
            <input type="checkbox" id="rightSupportToggle" checked />
        </div>
        <div class="input-row">
            <label>Moment of inertia (I):</label>
            <input type="number" id="inertiaInput" step="1e-6" />
        </div>
        <div id="spansContainer"></div>
        <button id="addSpanBtn">Add Span</button>
    </div>

    <div class="section">
        <h2>Point Loads</h2>
        <div id="pointLoadsContainer"></div>
        <button id="addPointLoadBtn">Add Point Load</button>
    </div>

    <div class="section">
        <h2>Line Loads</h2>
        <div id="lineLoadsContainer"></div>
        <button id="addLineLoadBtn">Add Line Load</button>
    </div>

    <div class="section">
        <h2>Load Combinations</h2>
        <div id="combContainer"></div>
        <button id="addCombBtn">Add Combination</button>
    </div>

    <div class="section">
        <h2>Support Reactions</h2>
        <pre id="reactionsOutput"></pre>
    </div>
    </div> <!-- end controls -->

    <div id="charts">
    <div id="selectedDisplay" class="full-width" style="font-weight:bold;"></div>
    <div class="section full-width">
        <h2>Loads</h2>
        <canvas id="loadsChart"></canvas>
    </div>

    <div class="section full-width">
        <h2>Shear Force Diagram</h2>
        <canvas id="shearChart"></canvas>
    </div>
    <div class="section full-width">
        <h2>Bending Moment Diagram</h2>
        <canvas id="momentChart"></canvas>
    </div>
    <div class="section full-width">
        <h2>Deflection</h2>
        <canvas id="deflectionChart"></canvas>
    </div>
    </div> <!-- end charts -->
    </div> <!-- end container -->
    </div> <!-- end analysisTab -->

    <div id="designTab" class="tabcontent">
    <div class="section">
        <h2>Cross-section Design</h2>
        <div class="input-row">
            <label>Material:</label>
            <select id="designMaterialSelect">
                <option value="steel" selected>Steel</option>
                <option value="timber">Timber</option>
            </select>
        </div>
        <div class="input-row">
            <label>Section:</label>
            <select id="designSectionSelect"></select>
        </div>
        <div class="input-row">
            <label>Steel grade:</label>
            <select id="steelSelect">
                <option value="235">S235</option>
                <option value="355" selected>S355</option>
                <option value="450">S450</option>
            </select>
        </div>
        <div class="input-row" id="timberGradeRow">
            <label>Timber grade:</label>
            <select id="timberSelect">
                <option value="C24" selected>C24</option>
                <option value="GL30c">GL30c</option>
            </select>
        </div>
        <div class="input-row">
            <label>Bending stiffness EI:</label>
            <span id="designEI">-</span>
        </div>
        <div class="input-row">
            <label>Section modulus W:</label>
            <span id="designW">-</span>
        </div>
        <div class="input-row">
            <label>Safety factor γ:</label>
            <span id="designGamma">-</span>
        </div>
        <div class="input-row">
            <label>Lateral bracing length:</label>
            <input type="number" id="designLb" value="3" step="0.1" />
        </div>
        <div class="input-row">
            <label>Bending resistance M,Rd:</label>
            <span id="designMRd">-</span>
        </div>
        <div class="input-row">
            <label>M,Rd,LBA:</label>
            <span id="designMRdLBA">-</span>
        </div>
        <div class="input-row">
            <label>Warping inertia Iw:</label>
            <span id="designIw">-</span>
        </div>
        <div class="input-row">
            <label>Torsional inertia It:</label>
            <span id="designIt">-</span>
        </div>
        <div class="input-row">
            <label>Weak-axis inertia Iz:</label>
            <span id="designIz">-</span>
        </div>
        <div class="input-row">
            <label>Critical moment Mcr:</label>
            <span id="designMcr">-</span>
        </div>
        <div class="input-row">
            <label>Reduction factor χ<sub>LT</sub>:</label>
            <span id="designChiLT">-</span>
        </div>
        <div class="input-row">
            <label>Shear resistance V,Rd:</label>
            <span id="designVRd">-</span>
        </div>
        <div class="input-row">
            <label>Bending utilization:</label>
            <span id="designMomentUtil">-</span>
        </div>
        <div class="input-row">
            <label>Shear utilization:</label>
            <span id="designShearUtil">-</span>
        </div>
        <div class="input-row">
            <svg id="sectionSvg" width="300" height="200" style="border:1px solid #ccc;" viewBox="0 0 300 200" role="img" aria-label="Cross-section"></svg>
        </div>
        <div class="input-row" id="designEquations"></div>
    </div>
    </div> <!-- end designTab -->

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="./steel_cross_sections_data.js"></script>
    <script src="./solver.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
    <script>
// State
const state = {
    spans: [],
    pointLoads: [],
    lineLoads: [],
    maxNodeDist: 0.2,
    material: 'steel',
    E: 210e9,
    I: 1e-6,
    section: null,
    fy: 355e6,
    fm_k: 24e6,
    fv_k: 4e6,
    includeSelfWeight: true,
    leftSupport: true,
    rightSupport: true,
    loadCombinations: [],
    selected: {type:'case', name:'LC1'},
    envelopeForces: null
};

let steelSections = {};
let timberSections = {};
let crossSections = {};
const timberGrades = {
    C24: {E:11e9,fm_k:24e6,fv_k:4e6},
    GL30c: {E:13e9,fm_k:30e6,fv_k:4e6}
};
function populateSectionSelect(){
    const sel = document.getElementById("sectionSelect");
    sel.innerHTML='';
    Object.keys(crossSections)
        .sort((a,b)=>a.localeCompare(b,undefined,{numeric:true}))
        .forEach(name=>{
        const opt=document.createElement("option");
        opt.value=name; opt.textContent=name;
        sel.appendChild(opt);
    });
    sel.selectedIndex=0;
    sel.dispatchEvent(new Event("change"));
}

function updateSectionProps(name){
    const table=document.getElementById('sectionPropsTable');
    const cs=crossSections[name];
    if(!cs){ table.innerHTML=''; return; }
    let html='<tr><th>Property</th><th>Value</th></tr>';
    Object.entries(cs).forEach(([k,v])=>{ html+=`<tr><td>${k}</td><td>${v}</td></tr>`; });
    table.innerHTML=html;
}

function setMaterial(mat){
    state.material = mat;
    crossSections = mat === 'timber' ? timberSections : steelSections;
    if(window.setCrossSections) window.setCrossSections(crossSections);
    populateSectionSelect();
    populateDesignSelect();
    if(mat==='timber') populateTimberSelect();
    else populateSteelSelect();
    const first = Object.keys(crossSections)[0];
    if(first){
        state.section = first;
        const cs = crossSections[first];
        state.I = cs.I_y !== undefined ? cs.I_y : (cs.Iy_m4 !== undefined ? cs.Iy_m4 : (cs.Iz_m4 !== undefined ? cs.Iz_m4 : cs.I_z));
        updateSectionProps(first);
        updateDesignProps(first);
        updateSelfWeightLineLoad();
    }
}

function loadCrossSections(){
    const promises=[];
    if(window.steelCrossSectionsData){
        steelSections = window.steelCrossSectionsData;
    } else {
        promises.push(fetch('./steel_cross_sections.json').then(r=>r.json()).then(d=>{steelSections={};d.forEach(cs=>{steelSections[cs.profile]=cs;});}));
    }
    promises.push(fetch('./timber_cross_sections.json').then(r=>r.json()).then(d=>{timberSections={};d.forEach(cs=>{timberSections[cs.profile]=cs;});}));
    Promise.all(promises).then(()=>{
        setMaterial(state.material || 'steel');
    });
}
loadCrossSections();
populateSteelSelect();
populateTimberSelect();
updateMaterialUI();

function addSpan(length = 5) {
    const idx = state.spans.length;
    state.spans.push({ length });
    const div = document.createElement('div');
    div.className = 'input-row';
    div.innerHTML = `<label>Span ${idx+1} length:</label>`+
        `<input type='number' value='${length}' min='0.1' step='0.1' `+
        `onchange='state.spans[${idx}].length=parseFloat(this.value); updateSelfWeightLineLoad(); updateWholeLineLoads(); solveSelected();' />`+
        `<button class='remove-btn' onclick='removeSpan(${idx})'>Remove</button>`;
    div.id = `span-${idx}`;
    document.getElementById('spansContainer').appendChild(div);
    updateSelfWeightLineLoad();
    updateWholeLineLoads();
    solveSelected();
}
function removeSpan(i) {
    state.spans.splice(i,1);
    document.getElementById('span-'+i).remove();
    // rebuild IDs
    rebuildSpans();
    updateSelfWeightLineLoad();
    updateWholeLineLoads();
    solveSelected();
}
function rebuildSpans(){
    const container = document.getElementById('spansContainer');
    container.innerHTML='';
    const spans=state.spans.slice();
    state.spans=[];
    spans.forEach(s=>addSpan(s.length));
}

function addPointLoad(P=10,x=0,lc='LC1'){
    const idx=state.pointLoads.length;
    state.pointLoads.push({P,x,case:lc});
    const div=document.createElement('div');
    div.className='input-row';
    div.innerHTML=`<label>Load ${idx+1} (P kN,x,case):</label>`+
    `<input type='number' value='${(P/1000)}' step='0.1' onchange='state.pointLoads[${idx}].P=parseFloat(this.value)*1000; solveSelected();'/>`+
    `<input type='number' value='${x}' step='0.1' onchange='state.pointLoads[${idx}].x=parseFloat(this.value); solveSelected();'/>`+
    `<input type='text' value='${lc}' onchange='state.pointLoads[${idx}].case=this.value; updateResultsOptions(); solveSelected();'/>`+
    `<button class='remove-btn' onclick='removePointLoad(${idx})'>Remove</button>`;
    div.id=`pload-${idx}`;
    document.getElementById('pointLoadsContainer').appendChild(div);
    updateResultsOptions();
    solveSelected();
}
function removePointLoad(i){
    state.pointLoads.splice(i,1);
    document.getElementById('pload-'+i).remove();
    rebuildPointLoads();
    updateResultsOptions();
    solveSelected();
}
function rebuildPointLoads(){
    const c=document.getElementById('pointLoadsContainer');
    c.innerHTML='';
    const arr=state.pointLoads.slice();
    state.pointLoads=[];
    arr.forEach(l=>addPointLoad(l.P,l.x,l.case));
}

function addLineLoad(w=5,start=0,end=1,lc='LC1',whole=false){
    const idx=state.lineLoads.length;
    state.lineLoads.push({w,start,end,case:lc,whole});
    const div=document.createElement('div');
    div.className='input-row';
    const dis=whole?'disabled':'';
    div.innerHTML=`<label>Line ${idx+1} (w kN/m,start,end,case):</label>`+
    `<input type='number' value='${(w/1000)}' step='0.1' oninput='state.lineLoads[${idx}].w=parseFloat(this.value)*1000; solveSelected();'/>`+
    `<input id='lload-start-${idx}' type='number' value='${start}' step='0.1' ${dis} oninput='state.lineLoads[${idx}].start=parseFloat(this.value); solveSelected();'/>`+
    `<input id='lload-end-${idx}' type='number' value='${end}' step='0.1' ${dis} oninput='state.lineLoads[${idx}].end=parseFloat(this.value); solveSelected();'/>`+
    `<input type='text' value='${lc}' onchange='state.lineLoads[${idx}].case=this.value; updateResultsOptions(); solveSelected();'/>`+
    `<label><input id='lload-whole-${idx}' type='checkbox' ${whole?'checked':''} onchange='toggleWholeLineLoad(${idx},this.checked);'/> across the whole beam</label>`+
    `<button class='remove-btn' onclick='removeLineLoad(${idx})'>Remove</button>`;
    div.id=`lload-${idx}`;
    document.getElementById('lineLoadsContainer').appendChild(div);
    updateResultsOptions();
    solveSelected();
}
function removeLineLoad(i){
    state.lineLoads.splice(i,1);
    document.getElementById('lload-'+i).remove();
    rebuildLineLoads();
    updateResultsOptions();
    solveSelected();
}
function rebuildLineLoads(){
    const c=document.getElementById('lineLoadsContainer');
    c.innerHTML='';
    const arr=state.lineLoads.slice();
    state.lineLoads=[];
    arr.forEach(l=>{
        if(l.autoSW){
            // preserve automatically generated self weight load
            state.lineLoads.push({w:l.w,start:l.start,end:l.end,case:'SW',autoSW:true});
            const div=document.createElement('div');
            div.className='input-row';
            div.id='lload-sw';
            div.innerHTML=`<label>Line SW (w kN/m,start,end,case):</label>`+
                `<input type='number' value='${(l.w/1000).toFixed(3)}' step='0.001' readonly />`+
                `<input type='number' value='${l.start}' step='0.1' readonly />`+
                `<input type='number' value='${l.end}' step='0.1' readonly />`+
                `<input type='text' value='SW' readonly />`;
            c.appendChild(div);
        } else {
            addLineLoad(l.w,l.start,l.end,l.case,l.whole);
        }
    });
    updateWholeLineLoads();
}

function updateSelfWeightLineLoad(){
    // remove existing auto-generated SW line load
    state.lineLoads = state.lineLoads.filter(l=>!l.autoSW);
    const existing=document.getElementById('lload-sw');
    if(existing) existing.remove();

    if(state.includeSelfWeight && state.section){
        const cs=crossSections[state.section];
        if(cs){
            const w=(cs.gk_kg_per_m*9.81); // N/m
            const len=state.spans.reduce((a,s)=>a+(typeof s==='number'?s:s.length),0);
            state.lineLoads.push({w,start:0,end:len,case:'SW',autoSW:true});
        }
    }
    rebuildLineLoads();
    solveSelected();
}

function getBeamLength(){
    return state.spans.reduce((a,s)=>a+(typeof s==='number'?s:s.length),0);
}

function toggleWholeLineLoad(i,checked){
    const len=getBeamLength();
    const l=state.lineLoads[i];
    l.whole=checked;
    if(checked){
        l.start=0;
        l.end=len;
    }
    const s=document.getElementById(`lload-start-${i}`);
    const e=document.getElementById(`lload-end-${i}`);
    if(s){s.disabled=checked; s.value=l.start;}
    if(e){e.disabled=checked; e.value=l.end;}
    solveSelected();
}

function updateWholeLineLoads(){
    const len=getBeamLength();
    state.lineLoads.forEach((l,i)=>{
        if(l.whole && !l.autoSW){
            l.start=0;
            l.end=len;
            const s=document.getElementById(`lload-start-${i}`);
            const e=document.getElementById(`lload-end-${i}`);
            if(s){s.disabled=true; s.value=0;}
            if(e){e.disabled=true; e.value=len;}
        }
    });
}

function hasOutOfRangeLoad(){
    const len=getBeamLength();
    for(const p of state.pointLoads){
        if(p.x<0 || p.x>len) return true;
    }
    for(const l of state.lineLoads){
        if(l.start<0 || l.end>len) return true;
    }
    return false;
}

function updateWarning(){
    const warn=document.getElementById('warningMsg');
    if(!warn) return;
    warn.textContent = hasOutOfRangeLoad() ? 'Warning: some loads are outside the beam length.' : '';
}

function parseFactors(str){
    const obj={};
    str.split(',').forEach(p=>{
        const [n,v]=p.split(':');
        if(n&&v) obj[n.trim()]=parseFloat(v);
    });
    return obj;
}

function addCombination(name=`Comb${state.loadCombinations.length+1}`,factorsStr='LC1:1'){
    const idx=state.loadCombinations.length;
    state.loadCombinations.push({name,factors:parseFactors(factorsStr)});
    const div=document.createElement('div');
    div.className='input-row';
    div.innerHTML=`<input type='text' value='${name}' onchange='state.loadCombinations[${idx}].name=this.value; updateResultsOptions();'/>`+
    `<input type='text' value='${factorsStr}' onchange='state.loadCombinations[${idx}].factors=parseFactors(this.value); solveSelected();'/>`+
    `<button class='remove-btn' onclick='removeCombination(${idx})'>Remove</button>`;
    div.id=`comb-${idx}`;
    document.getElementById('combContainer').appendChild(div);
    updateResultsOptions();
    solveSelected();
}

function removeCombination(i){
    state.loadCombinations.splice(i,1);
    document.getElementById('comb-'+i).remove();
    rebuildCombinations();
    updateResultsOptions();
    solveSelected();
}

function rebuildCombinations(){
    const c=document.getElementById('combContainer');
    const arr=state.loadCombinations.slice();
    c.innerHTML='';
    state.loadCombinations=[];
    arr.forEach(comb=>addCombination(comb.name,Object.entries(comb.factors).map(([k,v])=>`${k}:${v}`).join(',')));
}

function getLoadsForSelected(){
    const sel = (this && this.selected) || state.selected;
    if(sel.type==='case'){
        const name=sel.name;
        const pl=state.pointLoads.filter(l=>l.case===name);
        const ll=state.lineLoads.filter(l=>l.case===name);
        return {pointLoads:pl, lineLoads:ll};
    }
    if(sel.type==='comb'){
        const comb=state.loadCombinations[sel.index];
        const pl=[],ll=[];
        if(comb){
            Object.entries(comb.factors).forEach(([cn,f])=>{
                state.pointLoads.filter(l=>l.case===cn).forEach(l=>pl.push({P:l.P*f,x:l.x}));
                state.lineLoads.filter(l=>l.case===cn).forEach(l=>ll.push({w:l.w*f,start:l.start,end:l.end}));
            });
        }
        return {pointLoads:pl,lineLoads:ll};
    }
    return {pointLoads:[],lineLoads:[]};
}

function updateResultsOptions(){
    const sel=document.getElementById('resultsSelect');
    const prev=sel.value;
    sel.innerHTML='';
    const cases=new Set();
    state.pointLoads.forEach(l=>cases.add(l.case||'LC1'));
    state.lineLoads.forEach(l=>cases.add(l.case||'LC1'));
    Array.from(cases).sort((a,b)=>a.localeCompare(b,undefined,{numeric:true})).forEach(cn=>{
        const opt=document.createElement('option');
        opt.value=`case:${cn}`; opt.textContent=`Case ${cn}`;
        sel.appendChild(opt);
    });
    state.loadCombinations
        .map((c,i)=>({c,i}))
        .sort((a,b)=>a.c.name.localeCompare(b.c.name,undefined,{numeric:true}))
        .forEach(({c,i})=>{
        const opt=document.createElement('option');
        opt.value=`comb:${i}`; opt.textContent=`Comb ${c.name}`;
        sel.appendChild(opt);
    });
    if(state.loadCombinations.length>0){
        const opt=document.createElement('option');
        opt.value='envelope'; opt.textContent='Envelope';
        sel.appendChild(opt);
    }
    let setVal = prev && Array.from(sel.options).some(o=>o.value===prev) ? prev : null;
    if(!setVal){
        const lc1Opt=Array.from(sel.options).find(o=>o.value==='case:LC1');
        setVal = lc1Opt ? 'case:LC1' : (sel.options[0]?.value||'');
    }
    sel.value=setVal;
    const val=sel.value||'';
    if(val.startsWith('case:')) state.selected={type:'case',name:val.slice(5)};
    else if(val.startsWith('comb:')) state.selected={type:'comb',index:parseInt(val.slice(5))};
    else state.selected={type:'envelope'};
    updateSelectedText();
}

function updateSelectedText(){
    let txt='Envelope';
    if(state.selected.type==='case') txt='Load case '+state.selected.name;
    else if(state.selected.type==='comb') txt='Combination '+(state.loadCombinations[state.selected.index]?.name||'');
    document.getElementById('selectedDisplay').textContent='Showing results for: '+txt;
}

document.getElementById('addSpanBtn').onclick=()=>addSpan();
document.getElementById('addPointLoadBtn').onclick=()=>addPointLoad();
document.getElementById('addLineLoadBtn').onclick=()=>addLineLoad();
document.getElementById('addCombBtn').onclick=()=>addCombination();
document.getElementById('resultsSelect').onchange=function(){
    updateResultsOptions();
    solveSelected();
};
function updateMaterialUI(){
    const steelRow=document.getElementById('steelSelect').parentElement;
    if(steelRow) steelRow.style.display=state.material==='steel'?'flex':'none';
    const timberRow=document.getElementById('timberGradeRow');
    if(timberRow) timberRow.style.display=state.material==='timber'?'flex':'none';
}
document.getElementById('materialSelect').onchange=function(){
    state.material=this.value;
    if(this.value==='timber'){
        const g=timberGrades[document.getElementById('timberSelect').value];
        state.E=g.E; state.fm_k=g.fm_k; state.fv_k=g.fv_k; populateTimberSelect();
    } else {
        state.E=210e9; populateSteelSelect();
    }
    document.getElementById('designMaterialSelect').value=this.value;
    updateMaterialUI();
    setMaterial(this.value);
};
document.getElementById('designMaterialSelect').onchange=function(){
    state.material=this.value;
    if(this.value==='timber'){
        const g=timberGrades[document.getElementById('timberSelect').value];
        state.E=g.E; state.fm_k=g.fm_k; state.fv_k=g.fv_k; populateTimberSelect();
    } else {
        state.E=210e9; populateSteelSelect();
    }
    document.getElementById('materialSelect').value=this.value;
    updateMaterialUI();
    setMaterial(this.value);
};
document.getElementById('sectionSelect').onchange=function(){
    const name=this.value;
    state.section=name;
    if(crossSections[name]){
        const cs=crossSections[name];
        state.I = cs.I_y !== undefined ? cs.I_y : (cs.Iy_m4 !== undefined ? cs.Iy_m4 : (cs.Iz_m4 !== undefined ? cs.Iz_m4 : cs.I_z));
        document.getElementById('inertiaInput').value=state.I;
        updateSectionProps(name);
    }
    updateSelfWeightLineLoad();
    solveSelected();
};
document.getElementById('inertiaInput').onchange=function(){
    state.I=parseFloat(this.value);
    solveSelected();
};
document.getElementById('selfWeightToggle').onchange=function(){
    state.includeSelfWeight=this.checked;
    updateSelfWeightLineLoad();
    updateResultsOptions();
    solveSelected();
};
document.getElementById('leftSupportToggle').onchange=function(){
    state.leftSupport=this.checked;
    solveSelected();
};
document.getElementById('rightSupportToggle').onchange=function(){
    state.rightSupport=this.checked;
    solveSelected();
};
document.getElementById('designLb').onchange=function(){
    updateDesignProps(document.getElementById('designSectionSelect').value);
};

document.getElementById('inertiaInput').value = state.I;
document.getElementById('selfWeightToggle').checked = state.includeSelfWeight;
document.getElementById('leftSupportToggle').checked = state.leftSupport;
document.getElementById('rightSupportToggle').checked = state.rightSupport;

document.getElementById('maxNodeDist').onchange=function(){
    state.maxNodeDist=parseFloat(this.value);
    solveSelected();
};
document.getElementById('exportBtn').onclick=function(){
    window.print();
};

// FEM Solver
function solveSelected(){
    updateResultsOptions();
    updateWarning();
    computeEnvelopeForces();
    const sel=document.getElementById('designSectionSelect');
    if(sel) updateDesignProps(sel.value);
    if(state.selected.type==='envelope'){
        if(state.loadCombinations.length===0) return;
        const xsSet=new Set();
        const minS={},maxS={},minM={},maxM={},minD={},maxD={};
        state.loadCombinations.forEach((comb,i)=>{
            const loads=getLoadsForSelected.call({selected:{type:'comb',index:i}});
            const extraNodes=[
                ...new Set([
                    ...state.pointLoads.map(p=>p.x),
                    ...state.lineLoads.flatMap(l=>[l.start,l.end])
                ])
            ];
            const res=computeResults({
                ...state,
                pointLoads:loads.pointLoads,
                lineLoads:loads.lineLoads,
                extraNodePositions:extraNodes
            });
            const diagRaw=computeDiagrams({...state,pointLoads:loads.pointLoads,lineLoads:loads.lineLoads},res.nodes,res.reactions);
            const shearVals=diagRaw.shearVals.map(v=>-v);
            const momentVals=diagRaw.momentVals.map(v=>-v);
            const defVals=res.nodes.map((_,idx)=>res.displacements[2*idx]*1000);
            diagRaw.xs.forEach((x,j)=>{
                xsSet.add(x);
                if(minS[x]===undefined){minS[x]=shearVals[j]; maxS[x]=shearVals[j];}
                else{ if(shearVals[j]<minS[x]) minS[x]=shearVals[j]; if(shearVals[j]>maxS[x]) maxS[x]=shearVals[j]; }
                if(minM[x]===undefined){minM[x]=momentVals[j]; maxM[x]=momentVals[j];}
                else{ if(momentVals[j]<minM[x]) minM[x]=momentVals[j]; if(momentVals[j]>maxM[x]) maxM[x]=momentVals[j]; }
            });
            res.nodes.forEach((x,j)=>{
                xsSet.add(x);
                const v=defVals[j];
                if(minD[x]===undefined){minD[x]=v; maxD[x]=v;}
                else{ if(v<minD[x]) minD[x]=v; if(v>maxD[x]) maxD[x]=v; }
            });
        });
        const xs=Array.from(xsSet).sort((a,b)=>a-b);
        const minSArr=xs.map(x=>minS[x]);
        const maxSArr=xs.map(x=>maxS[x]);
        const minMArr=xs.map(x=>minM[x]);
        const maxMArr=xs.map(x=>maxM[x]);
        const minDArr=xs.map(x=>minD[x]);
        const maxDArr=xs.map(x=>maxD[x]);
        updateChart(shearChart,xs,[minSArr,maxSArr],'Shear');
        updateChart(momentChart,xs,[minMArr,maxMArr],'Moment');
        plotDeflection(xs,[minDArr,maxDArr]);
        document.getElementById("reactionsOutput").textContent='Envelope shown';
        const minShear=(Math.min(...minSArr)/1000).toFixed(2);
        const maxShear=(Math.max(...maxSArr)/1000).toFixed(2);
        const minMoment=(Math.min(...minMArr)/1000).toFixed(2);
        const maxMoment=(Math.max(...maxMArr)/1000).toFixed(2);
        const minDef=Math.min(...minDArr).toFixed(2);
        const maxDef=Math.max(...maxDArr).toFixed(2);
        const txt=`Shear: ${minShear} kN to ${maxShear} kN\n`+
                   `Moment: ${minMoment} kNm to ${maxMoment} kNm\n`+
                   `Deflection: ${minDef} mm to ${maxDef} mm`;
        document.getElementById("summaryOutput").textContent=txt;
        return;
    }
    const loads=getLoadsForSelected();
    const extraNodes=[
        ...new Set([
            ...state.pointLoads.map(p=>p.x),
            ...state.lineLoads.flatMap(l=>[l.start,l.end])
        ])
    ];
    const results = computeResults({
        ...state,
        pointLoads:loads.pointLoads,
        lineLoads:loads.lineLoads,
        extraNodePositions:extraNodes
    });
    if(!results) return;
    const {nodes,reactions,displacements,supportIndices} = results;
    const diag = plotDiagrams(nodes,reactions,loads,supportIndices);
    plotDeflection(nodes,displacements);
    showReactions(nodes,reactions,supportIndices);
    showSummary(diag,displacements,nodes);
}


function showReactions(nodes,reactions,supportIndices){
    const out=[];
    supportIndices.forEach((idx,i)=>{
        const R=reactions[2*idx]/1000;
        out.push(`Support ${i+1} reaction: ${R.toFixed(2)} kN`);
    });
    document.getElementById("reactionsOutput").textContent=out.join("\n");
}
function showSummary(diag,disp,nodes){
    const minShear=(Math.min(...diag.shearVals)/1000).toFixed(2);
    const maxShear=(Math.max(...diag.shearVals)/1000).toFixed(2);
    const minMoment=(Math.min(...diag.momentVals)/1000).toFixed(2);
    const maxMoment=(Math.max(...diag.momentVals)/1000).toFixed(2);
    const def=nodes.map((_,i)=>-disp[2*i]);
    const minDef=(Math.min(...def)*1000).toFixed(2);
    const maxDef=(Math.max(...def)*1000).toFixed(2);
    const txt=`Shear: ${minShear} kN to ${maxShear} kN\n`+
               `Moment: ${minMoment} kNm to ${maxMoment} kNm\n`+
               `Deflection: ${minDef} mm to ${maxDef} mm`;
    document.getElementById("summaryOutput").textContent=txt;
}


function plotDiagrams(nodes,reactions,loads,supportIndices){
    const events=[];
    const totalLength=nodes[nodes.length-1];
    for(let i=0;i<nodes.length;i++) events.push({x:nodes[i],P:reactions[2*i]});
    (loads.pointLoads||[]).forEach(p=>events.push({x:p.x,P:p.P}));
    (loads.lineLoads||[]).forEach(l=>events.push({x:l.start,w:l.w,start:true}));
    (loads.lineLoads||[]).forEach(l=>events.push({x:l.end,w:l.w,end:true}));
    events.sort((a,b)=>a.x-b.x);

    let shear=0, moment=0;
    const xs=[0],shearVals=[0],momentVals=[0];
    const loadXs=[0],loadVals=[0];
    let activeWs=[];
    for(let i=0;i<events.length;i++){
        const e=events[i];
        const dx=e.x-xs[xs.length-1];
        const wBefore=activeWs.reduce((a,b)=>a+b,0);
        const shearBefore=shear;
        shear-=wBefore*dx;
        moment+=shearBefore*dx - 0.5*wBefore*dx*dx;
        xs.push(e.x); shearVals.push(shear); momentVals.push(moment);
        loadXs.push(e.x); loadVals.push(wBefore);

        if(e.P){
            shear-=e.P;
            xs.push(e.x); shearVals.push(shear); momentVals.push(moment);
        }
        if(e.start){activeWs.push(e.w);} 
        if(e.end){
            const idx=activeWs.indexOf(e.w);
            if(idx>-1) activeWs.splice(idx,1);
        }
        const wAfter=activeWs.reduce((a,b)=>a+b,0);
        loadXs.push(e.x); loadVals.push(wAfter);
    }
    const lastX=xs[xs.length-1];
    const lastL=loadXs[loadXs.length-1];
    if(lastX<totalLength){
        const dx=totalLength-lastX;
        const wTotal=activeWs.reduce((a,b)=>a+b,0);
        const shearBefore=shear;
        shear-=wTotal*dx;
        moment+=shearBefore*dx -0.5*wTotal*dx*dx;
        xs.push(totalLength); shearVals.push(shear); momentVals.push(moment);
    }
    if(lastL<totalLength){
        loadXs.push(totalLength); loadVals.push(activeWs.reduce((a,b)=>a+b,0));
    }
    // flip sign so downward loads give sagging moments and downward shear
    const shearAdj=shearVals.map(v=>-v);
    const momentAdj=momentVals.map(v=>-v);
    const pointData=(loads.pointLoads||[]).map(p=>({x:p.x,y:p.P}));
    const reactionsScatter=(supportIndices||[]).map(idx=>({x:nodes[idx],y:reactions[2*idx]}));
    updateChart(loadChart,loadXs,loadVals,'Loads',pointData,reactionsScatter);
    updateChart(shearChart,xs,shearAdj,'Shear');
    updateChart(momentChart,xs,momentAdj,'Moment');
    return {xs,shearVals:shearAdj, momentVals:momentAdj};
}

function plotDeflection(nodes,U){
    const xs=nodes.slice();
    if(Array.isArray(U[0])){
        const neg=U.map(arr=>arr.map(v=>-v));
        updateChart(deflectionChart,xs,neg,'Deflection');
    } else {
        const def=[];
        for(let i=0;i<xs.length;i++) def.push(-U[2*i]*1000);
        updateChart(deflectionChart,xs,def,'Deflection');
    }
}

let shearChart=null,momentChart=null,deflectionChart=null,loadChart=null;
const reactionPlugin={
    id:'reactionPlugin',
    afterDatasetsDraw(chart,args,opts){
        const reactions=chart.options.reactions||[];
        if(reactions.length===0) return;
        const ctx=chart.ctx;
        ctx.save();
        ctx.fillStyle='black';
        ctx.font='12px sans-serif';
        reactions.forEach(r=>{
            const xPix=chart.scales.x.getPixelForValue(r.x);
            const yPix=chart.scales.y.getPixelForValue(0);
            ctx.fillText(r.y.toFixed(2)+' kN',xPix+5,yPix-5);
        });
        ctx.restore();
    }
};
if(window.Chart) Chart.register(reactionPlugin);

function updateChart(chart,x,y,label,scatter,reactions){
    const isEnvelope=Array.isArray(y[0]);
    let unitLabel='';
    if(label==='Shear' || label==='Moment'){
        const scaleData=arr=>arr.map(v=>v/1000);
        if(isEnvelope){
            y=[scaleData(y[0]),scaleData(y[1])];
        } else {
            y=scaleData(y);
        }
        unitLabel=label==='Shear'?' (kN)':' (kNm)';
    } else if(label==='Loads'){
        const scaleData=arr=>arr.map(v=>v/1000);
        y=scaleData(y);
        if(scatter) scatter=scatter.map(p=>({x:p.x,y:p.y/1000}));
        if(reactions) reactions=reactions.map(r=>({x:r.x,y:r.y/1000}));
        unitLabel=' (kN/m)';
    }
    if(chart){
        chart.destroy();
        chart=null;
        if(label==='Shear') shearChart=null;
        if(label==='Moment') momentChart=null;
        if(label==='Deflection') deflectionChart=null;
        if(label==='Loads') loadChart=null;
    }
    const ctx=document.getElementById(label.toLowerCase()+'Chart').getContext('2d');
    let datasets;
    if(isEnvelope){
        const dmin=x.map((v,i)=>({x:v,y:y[0][i]}));
        const dmax=x.map((v,i)=>({x:v,y:y[1][i]}));
        datasets=[
            {label:label+' min',data:dmin,fill:true,borderColor:'blue',backgroundColor:'rgba(0,0,255,0.2)',showLine:true},
            {label:label+' max',data:dmax,fill:true,borderColor:'green',backgroundColor:'rgba(0,255,0,0.2)',showLine:true}
        ];
    } else {
        const xyData=x.map((v,i)=>({x:v,y:y[i]}));
        datasets=[{label:label,data:xyData,fill:true,borderColor:'blue',backgroundColor:'rgba(0,0,255,0.2)',showLine:true}];
    }
    if(scatter){
        datasets.push({type:'scatter',label:'P',data:scatter,borderColor:'red',backgroundColor:'red',showLine:false});
    }
    const zeroLine=x.map(v=>({x:v,y:0}));
    datasets.unshift({label:'Beam',data:zeroLine,fill:false,borderColor:'black',borderWidth:3,pointRadius:0,showLine:true});
    if(reactions){
        datasets.push({type:'scatter',label:'R',data:reactions,borderColor:'orange',backgroundColor:'orange',showLine:false});
    }
    const yTitle=label+unitLabel;
    const newChart=new Chart(ctx,{type:'line',data:{datasets},options:{scales:{x:{type:'linear',title:{display:true,text:'x'}},y:{title:{display:true,text:yTitle}}},reactions:reactions||[]}});
    if(label==='Shear') shearChart=newChart;
    if(label==='Moment') momentChart=newChart;
    if(label==='Deflection') deflectionChart=newChart;
    if(label==='Loads') loadChart=newChart;
}

function computeEnvelopeForces(){
    if(state.loadCombinations.length===0){ state.envelopeForces=null; return; }
    const xsSet=new Set();
    const minS={},maxS={},minM={},maxM={};
    state.loadCombinations.forEach((comb,i)=>{
        const loads=getLoadsForSelected.call({selected:{type:'comb',index:i}});
        const extraNodes=[
            ...new Set([
                ...state.pointLoads.map(p=>p.x),
                ...state.lineLoads.flatMap(l=>[l.start,l.end])
            ])
        ];
        const res=computeResults({
            ...state,
            pointLoads:loads.pointLoads,
            lineLoads:loads.lineLoads,
            extraNodePositions:extraNodes
        });
        const diag=computeDiagrams({...state,pointLoads:loads.pointLoads,lineLoads:loads.lineLoads},res.nodes,res.reactions);
        const shearVals=diag.shearVals.map(v=>-v);
        const momentVals=diag.momentVals.map(v=>-v);
        diag.xs.forEach((x,j)=>{
            xsSet.add(x);
            if(minS[x]===undefined){minS[x]=shearVals[j]; maxS[x]=shearVals[j];}
            else { if(shearVals[j]<minS[x]) minS[x]=shearVals[j]; if(shearVals[j]>maxS[x]) maxS[x]=shearVals[j]; }
            if(minM[x]===undefined){minM[x]=momentVals[j]; maxM[x]=momentVals[j];}
            else { if(momentVals[j]<minM[x]) minM[x]=momentVals[j]; if(momentVals[j]>maxM[x]) maxM[x]=momentVals[j]; }
        });
    });
    const xs=Array.from(xsSet).sort((a,b)=>a-b);
    const minSArr=xs.map(x=>minS[x]);
    const maxSArr=xs.map(x=>maxS[x]);
    const minMArr=xs.map(x=>minM[x]);
    const maxMArr=xs.map(x=>maxM[x]);
    state.envelopeForces={
        minShear: Math.min(...minSArr),
        maxShear: Math.max(...maxSArr),
        minMoment: Math.min(...minMArr),
        maxMoment: Math.max(...maxMArr)
    };
}

function populateDesignSelect(){
    const sel=document.getElementById('designSectionSelect');
    if(!sel) return;
    sel.innerHTML='';
    Object.keys(crossSections)
        .sort((a,b)=>a.localeCompare(b,undefined,{numeric:true}))
        .forEach(name=>{
            const opt=document.createElement('option');
            opt.value=name; opt.textContent=name;
            sel.appendChild(opt);
        });
    sel.onchange=function(){ updateDesignProps(this.value); };
    sel.selectedIndex=0;
    updateDesignProps(sel.value);
}

function populateSteelSelect(){
    const sel=document.getElementById('steelSelect');
    if(!sel) return;
    state.fy=parseFloat(sel.value)*1e6;
    sel.onchange=function(){
        state.fy=parseFloat(this.value)*1e6;
        updateDesignProps(document.getElementById('designSectionSelect').value);
    };
}

function populateTimberSelect(){
    const sel=document.getElementById('timberSelect');
    if(!sel) return;
    const apply=()=>{
        const g=timberGrades[sel.value];
        if(!g) return;
        state.E=g.E;
        state.fm_k=g.fm_k;
        state.fv_k=g.fv_k;
        updateDesignProps(document.getElementById('designSectionSelect').value);
    };
    sel.onchange=apply;
    apply();
}

function computeSectionOutline(cs){
    const b = cs.b_mm, h = cs.h_mm, tw = cs.tw_mm, tf = cs.tf_mm, r = cs.r_mm || 0;
    const rw = b / 2 + tw / 2, lw = b / 2 - tw / 2;
    const steps = 6;
    const pts = [];
    function arc(cx, cy, rad, a1, a2){
        for(let i = 0; i <= steps; i++){
            const t = a1 + (a2 - a1) * i / steps;
            pts.push({x: cx + rad * Math.cos(t), y: cy + rad * Math.sin(t)});
        }
    }

    pts.push({x: 0, y: 0});
    pts.push({x: b, y: 0});
    pts.push({x: b, y: tf});
    if(r > 0){
        pts.push({x: rw + r, y: tf});
        arc(rw + r, tf + r, r, 1.5 * Math.PI, Math.PI);
        pts.push({x: rw, y: tf + r});
    } else {
        pts.push({x: rw, y: tf});
    }
    pts.push({x: rw, y: h - tf - r});
    if(r > 0){
        arc(rw + r, h - tf - r, r, Math.PI, Math.PI / 2);
        pts.push({x: rw + r, y: h - tf});
    } else {
        pts.push({x: rw, y: h - tf});
    }
    pts.push({x: b, y: h - tf});
    pts.push({x: b, y: h});
    pts.push({x: 0, y: h});
    pts.push({x: 0, y: h - tf});
    if(r > 0){
        pts.push({x: lw - r, y: h - tf});
        arc(lw - r, h - tf - r, r, Math.PI / 2, 0);
        pts.push({x: lw, y: h - tf - r});
    } else {
        pts.push({x: lw, y: h - tf});
    }
    pts.push({x: lw, y: tf + r});
    if(r > 0){
        arc(lw - r, tf + r, r, 0, -Math.PI / 2);
        pts.push({x: lw - r, y: tf});
    } else {
        pts.push({x: lw, y: tf});
    }
    pts.push({x: 0, y: tf});
    pts.push({x: 0, y: 0});
    return pts;
}

function drawSectionGraphic(cs){
    const svg = document.getElementById('sectionSvg');
    if (!svg) { return; }
    svg.innerHTML = '';
    if (!cs) { return; }

    const width = svg.clientWidth;
    const height = svg.clientHeight;
    const margin = Math.max(cs.h_mm, cs.b_mm) * 0.1;

    const scale = Math.min(
        (width - 2 * margin) / cs.b_mm,
        (height - 2 * margin) / cs.h_mm
    );
    const x0 = (width - cs.b_mm * scale) / 2;
    const y0 = (height - cs.h_mm * scale) / 2;
    const mapX = x => x0 + x * scale;
    const mapY = y => height - (y0 + y * scale);

    const points = computeSectionOutline(cs).map(p => [mapX(p.x), mapY(p.y)]);
    const svgSel = d3.select(svg);
    svgSel
        .append('polygon')
        .attr('points', points.map(p => p.join(',')).join(' '))
        .attr('fill', '#ccc')
        .attr('stroke', 'black');

    // arrow marker for dimension lines
    const defs = svgSel.append('defs');
    defs
        .append('marker')
        .attr('id', 'dimArrow')
        .attr('viewBox', '0 0 10 10')
        .attr('refX', 5)
        .attr('refY', 5)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M 0 0 L 10 5 L 0 10 z')
        .attr('fill', 'black');

    const dimAttrs = {
        stroke: 'black',
        'stroke-width': 1,
        'marker-start': 'url(#dimArrow)',
        'marker-end': 'url(#dimArrow)'
    };

    const bottomY = mapY(0) + 20;
    svgSel.append('line')
        .attr('x1', mapX(0))
        .attr('y1', bottomY)
        .attr('x2', mapX(cs.b_mm))
        .attr('y2', bottomY)
        .attr('stroke', dimAttrs.stroke)
        .attr('stroke-width', dimAttrs['stroke-width'])
        .attr('marker-start', dimAttrs['marker-start'])
        .attr('marker-end', dimAttrs['marker-end']);
    svgSel.append('text')
        .attr('x', (mapX(0) + mapX(cs.b_mm)) / 2)
        .attr('y', bottomY - 4)
        .attr('text-anchor', 'middle')
        .attr('font-size', 12)
        .text(cs.b_mm + ' mm');

    const leftX = mapX(0) - 20;
    svgSel.append('line')
        .attr('x1', leftX)
        .attr('y1', mapY(0))
        .attr('x2', leftX)
        .attr('y2', mapY(cs.h_mm))
        .attr('stroke', dimAttrs.stroke)
        .attr('stroke-width', dimAttrs['stroke-width'])
        .attr('marker-start', dimAttrs['marker-start'])
        .attr('marker-end', dimAttrs['marker-end']);
    svgSel.append('text')
        .attr('x', leftX - 4)
        .attr('y', (mapY(0) + mapY(cs.h_mm)) / 2)
        .attr('text-anchor', 'middle')
        .attr('font-size', 12)
        .attr('transform', `rotate(-90 ${leftX - 4}, ${(mapY(0) + mapY(cs.h_mm)) / 2})`)
        .text(cs.h_mm + ' mm');
}

function updateDesignEquations(design){
    const div=document.getElementById('designEquations');
    if(!div){return;}
    if(!design){ div.innerHTML=''; if(window.MathJax) MathJax.typesetPromise([div]); return; }
    const disp=v=>v==='-'?`\\text{--}`:v;
    const mRd=(design.MRd/1000).toFixed(1);
    const mRdLBA=(design.MRdLBA/1000).toFixed(1);
    const vRd=(design.VRd/1000).toFixed(1);
    if(design.material==='timber'){
        div.innerHTML=String.raw`$$M_{Rd}=\frac{W f_{m,k}}{\gamma_M}=${disp(mRd)}\,\mathrm{kN\,m}$$<br>`+
                     String.raw`$$M_{Rd,LBA}=k_{crit} W f_{m,d}=${disp(mRdLBA)}\,\mathrm{kN\,m}$$<br>`+
                     String.raw`$$V_{Rd}=\frac{A_v f_{v,k}}{\gamma_M}=${disp(vRd)}\,\mathrm{kN}$$`;
    } else {
        const iw=design.Iw!==undefined?design.Iw.toExponential(2):'-';
        const it=design.It!==undefined?design.It.toExponential(2):'-';
        const iz=design.Iz!==undefined?design.Iz.toExponential(2):'-';
        const lb=design.Lb!==undefined?design.Lb.toFixed(2):'-';
        const e=design.E!==undefined?(design.E/1e9).toFixed(1):'-';
        const g=design.G!==undefined?(design.G/1e9).toFixed(1):'-';
        const c1=design.C1!==undefined?design.C1.toFixed(2):'-';
        const c2=design.C2!==undefined?design.C2.toFixed(2):'-';
        const c3=design.C3!==undefined?design.C3.toFixed(2):'-';
        const kw=design.kw!==undefined?design.kw.toFixed(2):'-';
        const mcr=design.Mcr!==undefined?(design.Mcr/1000).toFixed(1):'-';
        const chi=design.chiLT!==undefined?design.chiLT.toFixed(3):'-';
        div.innerHTML=String.raw`$$M_{Rd}=\frac{W f_y}{\gamma_{M0}}=${disp(mRd)}\,\mathrm{kN\,m}$$<br>`+
                     String.raw`$$M_{Rd,LBA}=\chi_{LT} \frac{W f_y}{\gamma_{M0}}=${disp(mRdLBA)}\,\mathrm{kN\,m}$$<br>`+
                     String.raw`$$V_{Rd}=\frac{A_v f_y}{\sqrt{3}\,\gamma_{M0}}=${disp(vRd)}\,\mathrm{kN}$$<br>`+
                     String.raw`$$I_z=${disp(iz)}\,\mathrm{m^4},\ I_t=${disp(it)}\,\mathrm{m^4},\ I_w=${disp(iw)}\,\mathrm{m^6}$$<br>`+
                     String.raw`$$L_b=${disp(lb)}\,\mathrm{m},\ E=${disp(e)}\,\mathrm{GPa},\ G=${disp(g)}\,\mathrm{GPa}$$<br>`+
                     String.raw`$$C_1=${disp(c1)},\ C_2=${disp(c2)},\ C_3=${disp(c3)},\ k_w=${disp(kw)}$$<br>`+
                     String.raw`$$M_{cr}=C_1 \frac{\pi^2 E I_z}{L_b^2} \sqrt{\frac{I_w}{I_z}+\frac{L_b^2 G I_t}{\pi^2 E I_z}}=${disp(mcr)}\,\mathrm{kN\,m},\ \chi_{LT}=${disp(chi)}$$`;
    }
    if(window.MathJax) MathJax.typesetPromise([div]);
}

function updateDesignProps(name){
    const cs=crossSections[name];
    const EIel=document.getElementById('designEI');
    const Wel=document.getElementById('designW');
    const gammaEl=document.getElementById('designGamma');
    const MRdel=document.getElementById('designMRd');
    const MRdLBdel=document.getElementById('designMRdLBA');
    const Iwel=document.getElementById('designIw');
    const Itel=document.getElementById('designIt');
    const IzEl=document.getElementById('designIz');
    const McrEl=document.getElementById('designMcr');
    const chiEl=document.getElementById('designChiLT');
    const VRdel=document.getElementById('designVRd');
    const Mutil=document.getElementById('designMomentUtil');
    const Vutil=document.getElementById('designShearUtil');
    drawSectionGraphic(cs);
    if(!cs){ EIel.textContent='-'; if(Wel) Wel.textContent='-'; if(gammaEl) gammaEl.textContent='-'; MRdel.textContent='-'; if(MRdLBdel) MRdLBdel.textContent='-'; if(Iwel) Iwel.textContent='-'; if(Itel) Itel.textContent='-'; if(IzEl) IzEl.textContent='-'; if(McrEl) McrEl.textContent='-'; if(chiEl) chiEl.textContent='-'; VRdel.textContent='-'; if(Mutil) Mutil.textContent='-'; if(Vutil) Vutil.textContent='-'; updateDesignEquations(null); return; }
    let design=null;
    if(window.computeSectionDesign){
        const Lb=parseFloat(document.getElementById('designLb').value);
        design=computeSectionDesign(name,{fy:state.fy,E:state.E,material:state.material,fm_k:state.fm_k,fv_k:state.fv_k,unbracedLength:Lb});
    }
    const Iy = cs.I_y !== undefined ? cs.I_y : (cs.Iy_m4 !== undefined ? cs.Iy_m4 : (cs.Iz_m4 !== undefined ? cs.Iz_m4 : cs.I_z));
    const EIval=(design?design.EI:state.E*Iy)/1000;
    EIel.textContent=EIval.toFixed(1)+' kN\u00b7m\u00b2';
    if(design){
        const Wcm3=(design.W*1e6).toFixed(1);
        if(Wel) Wel.textContent=Wcm3+' cm\u00b3';
        if(gammaEl) gammaEl.textContent=design.gamma.toFixed(2);
    } else {
        if(Wel) Wel.textContent='-';
        if(gammaEl) gammaEl.textContent='-';
    }
    if(design){
        MRdel.textContent=(design.MRd/1000).toFixed(1)+' kNm';
        if(MRdLBdel) MRdLBdel.textContent=(design.MRdLBA/1000).toFixed(1)+' kNm';
        if(Iwel && design.Iw!==undefined) Iwel.textContent=design.Iw.toExponential(2)+' m\u2076';
        if(Itel && design.It!==undefined) Itel.textContent=design.It.toExponential(2)+' m\u2074';
        if(IzEl && design.Iz!==undefined) IzEl.textContent=design.Iz.toExponential(2)+' m\u2074';
        if(McrEl && design.Mcr!==undefined) McrEl.textContent=(design.Mcr/1000).toFixed(1)+' kNm';
        if(chiEl && design.chiLT!==undefined) chiEl.textContent=design.chiLT.toFixed(3);
        VRdel.textContent=(design.VRd/1000).toFixed(1)+' kN';
        updateDesignEquations(design);
        if(state.envelopeForces){
            const mAbs=Math.max(Math.abs(state.envelopeForces.minMoment), Math.abs(state.envelopeForces.maxMoment));
            const vAbs=Math.max(Math.abs(state.envelopeForces.minShear), Math.abs(state.envelopeForces.maxShear));
            if(Mutil){
                const val=(100*mAbs/design.MRdLBA);
                Mutil.textContent=val.toFixed(1)+'%';
                Mutil.style.color=val<=100?'green':'red';
            }
            if(Vutil){
                const val=(100*vAbs/design.VRd);
                Vutil.textContent=val.toFixed(1)+'%';
                Vutil.style.color=val<=100?'green':'red';
            }
        } else {
            if(Mutil){ Mutil.textContent='-'; Mutil.style.color=''; }
            if(Vutil){ Vutil.textContent='-'; Vutil.style.color=''; }
        }
    } else {
        MRdel.textContent='-';
        if(MRdLBdel) MRdLBdel.textContent='-';
        if(Iwel) Iwel.textContent='-';
        if(Itel) Itel.textContent='-';
        if(IzEl) IzEl.textContent='-';
        if(McrEl) McrEl.textContent='-';
        if(chiEl) chiEl.textContent='-';
        VRdel.textContent='-';
        if(Mutil){ Mutil.textContent='-'; Mutil.style.color=''; }
        if(Vutil){ Vutil.textContent='-'; Vutil.style.color=''; }
        updateDesignEquations(null);
    }
}

function showTab(name){
    document.getElementById('analysisTab').style.display=name==='analysis'?'block':'none';
    document.getElementById('designTab').style.display=name==='design'?'block':'none';
    document.querySelectorAll('#tabs button').forEach(btn=>{
        btn.classList.toggle('active', btn.dataset.tab===name);
    });
    if(name==='design'){
        const sel=document.getElementById('designSectionSelect');
        if(sel) updateDesignProps(sel.value);
    }
}

addSpan(10);
addLineLoad(5000,0,10);
addCombination('Comb1','SW:1.35,LC1:1.50');
addCombination('Comb2','SW:0.90,LC1:1.50');
solveSelected();
    </script>
</body>
</html>
