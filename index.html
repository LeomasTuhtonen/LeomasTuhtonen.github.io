<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beam Calculator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background:#f4f4f4; color:#333; }
        #container { display:flex; flex-wrap:wrap; gap:20px; padding:20px; }
        #controls { flex:1 1 300px; max-width:400px; }
        #charts { flex:1 1 600px; display:grid; grid-template-columns:1fr 1fr; gap:20px; }
        #charts .section { min-width:0; }
        #charts .full-width { grid-column:1 / -1; }
        .section { background:#fff; padding:15px; border-radius:8px; box-shadow:0 2px 5px rgba(0,0,0,0.1); margin-bottom:20px; }
        .input-row { margin-bottom: 10px; }
        label { display: inline-block; width: 140px; }
        input[type='number'], select { width: 100px; padding:4px; }
        #sectionPropsTable { border-collapse: collapse; margin-top:4px; }
        #sectionPropsTable td, #sectionPropsTable th { border: 1px solid #ccc; padding:2px 4px; font-size:12px; }
        canvas { width: 100%; height: 250px; margin-top: 20px; background:#fff; border:1px solid #ddd; padding:10px; border-radius:4px; }
        button { padding:6px 12px; margin-top:4px; background:#4CAF50; color:white; border:none; border-radius:4px; cursor:pointer; }
        button:hover { background:#45a049; }
        h1 { text-align:center; padding:20px 0; margin:0; background:#fff; box-shadow:0 2px 4px rgba(0,0,0,0.1); margin-bottom:20px; }
    </style>
</head>
<body>
    <h1>Beam Calculator</h1>
    <div id="container">
    <div id="controls">
    <div class="section">
        <h2>Results</h2>
        <div class="input-row">
            <label>Show results for:</label>
            <select id="resultsSelect"></select>
            <button id="exportBtn">Export PDF</button>
        </div>
        <pre id="summaryOutput"></pre>
    </div>

    <div class="section">
        <h2>Beam Setup</h2>
        <div class="input-row">
            <label>Max node distance:</label>
            <input type="number" id="maxNodeDist" value="1" min="0.1" step="0.1" />
        </div>
        <div class="input-row">
            <label>Cross-section:</label>
            <select id="sectionSelect"></select>
        </div>
        <div class="input-row">
            <label></label>
            <table id="sectionPropsTable"></table>
        </div>
        <div class="input-row">
            <label>Include self weight:</label>
            <input type="checkbox" id="selfWeightToggle" checked />
        </div>
        <div class="input-row">
            <label>Left support present:</label>
            <input type="checkbox" id="leftSupportToggle" checked />
        </div>
        <div class="input-row">
            <label>Right support present:</label>
            <input type="checkbox" id="rightSupportToggle" checked />
        </div>
        <div class="input-row">
            <label>Moment of inertia (I):</label>
            <input type="number" id="inertiaInput" step="1e-6" />
        </div>
        <div id="spansContainer"></div>
        <button id="addSpanBtn">Add Span</button>
    </div>

    <div class="section">
        <h2>Point Loads</h2>
        <div id="pointLoadsContainer"></div>
        <button id="addPointLoadBtn">Add Point Load</button>
    </div>

    <div class="section">
        <h2>Line Loads</h2>
        <div id="lineLoadsContainer"></div>
        <button id="addLineLoadBtn">Add Line Load</button>
    </div>

    <div class="section">
        <h2>Load Combinations</h2>
        <div id="combContainer"></div>
        <button id="addCombBtn">Add Combination</button>
    </div>

    <div class="section">
        <h2>Support Reactions</h2>
        <pre id="reactionsOutput"></pre>
    </div>
    </div> <!-- end controls -->

    <div id="charts">
    <div id="selectedDisplay" class="full-width" style="font-weight:bold;"></div>
    <div class="section full-width">
        <h2>Loads</h2>
        <canvas id="loadsChart"></canvas>
    </div>

    <div class="section full-width">
        <h2>Shear Force Diagram</h2>
        <canvas id="shearChart"></canvas>
    </div>
    <div class="section full-width">
        <h2>Bending Moment Diagram</h2>
        <canvas id="momentChart"></canvas>
    </div>
    <div class="section full-width">
        <h2>Deflection</h2>
        <canvas id="deflectionChart"></canvas>
    </div>
    </div> <!-- end charts -->
    </div> <!-- end container -->

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="cross_sections_data.js"></script>
    <script src="solver.js"></script>
    <script>
// State
const state = {
    spans: [],
    pointLoads: [],
    lineLoads: [],
    maxNodeDist: 1,
    E: 210e9,
    I: 1e-6,
    section: null,
    includeSelfWeight: true,
    leftSupport: true,
    rightSupport: true,
    loadCombinations: [],
    selected: {type:'case', name:'LC1'}
};

let crossSections = {};
function populateSectionSelect(){
    const sel = document.getElementById("sectionSelect");
    sel.innerHTML='';
    Object.keys(crossSections)
        .sort((a,b)=>a.localeCompare(b,undefined,{numeric:true}))
        .forEach(name=>{
        const opt=document.createElement("option");
        opt.value=name; opt.textContent=name;
        sel.appendChild(opt);
    });
    sel.selectedIndex=0;
    sel.dispatchEvent(new Event("change"));
}

function updateSectionProps(name){
    const table=document.getElementById('sectionPropsTable');
    const cs=crossSections[name];
    if(!cs){ table.innerHTML=''; return; }
    let html='<tr><th>Property</th><th>Value</th></tr>';
    Object.entries(cs).forEach(([k,v])=>{ html+=`<tr><td>${k}</td><td>${v}</td></tr>`; });
    table.innerHTML=html;
}

function loadCrossSections(){
    if(window.crossSectionsData){
        crossSections = window.crossSectionsData;
        if(window.setCrossSections) window.setCrossSections(crossSections);
        populateSectionSelect();
        updateSectionProps(Object.keys(crossSections)[0]);
    } else {
        fetch('cross_sections.json').then(r=>r.json()).then(data=>{
            crossSections={};
            data.forEach(cs=>{crossSections[cs.profile]=cs;});
            if(window.setCrossSections) window.setCrossSections(crossSections);
            populateSectionSelect();
            updateSectionProps(Object.keys(crossSections)[0]);
        });
    }
}
loadCrossSections();

function addSpan(length = 5) {
    const idx = state.spans.length;
    state.spans.push({ length });
    const div = document.createElement('div');
    div.className = 'input-row';
    div.innerHTML = `<label>Span ${idx+1} length:</label>`+
        `<input type='number' value='${length}' min='0.1' step='0.1' `+
        `onchange='state.spans[${idx}].length=parseFloat(this.value); solveSelected();' />`+
        `<button onclick='removeSpan(${idx})'>Remove</button>`;
    div.id = `span-${idx}`;
    document.getElementById('spansContainer').appendChild(div);
    updateSelfWeightLineLoad();
    solveSelected();
}
function removeSpan(i) {
    state.spans.splice(i,1);
    document.getElementById('span-'+i).remove();
    // rebuild IDs
    rebuildSpans();
    updateSelfWeightLineLoad();
    solveSelected();
}
function rebuildSpans(){
    const container = document.getElementById('spansContainer');
    container.innerHTML='';
    const spans=state.spans.slice();
    state.spans=[];
    spans.forEach(s=>addSpan(s.length));
}

function addPointLoad(P=10,x=0,lc='LC1'){
    const idx=state.pointLoads.length;
    state.pointLoads.push({P,x,case:lc});
    const div=document.createElement('div');
    div.className='input-row';
    div.innerHTML=`<label>Load ${idx+1} (P kN,x,case):</label>`+
    `<input type='number' value='${(P/1000)}' step='0.1' onchange='state.pointLoads[${idx}].P=parseFloat(this.value)*1000; solveSelected();'/>`+
    `<input type='number' value='${x}' step='0.1' onchange='state.pointLoads[${idx}].x=parseFloat(this.value); solveSelected();'/>`+
    `<input type='text' value='${lc}' onchange='state.pointLoads[${idx}].case=this.value; updateResultsOptions(); solveSelected();'/>`+
    `<button onclick='removePointLoad(${idx})'>Remove</button>`;
    div.id=`pload-${idx}`;
    document.getElementById('pointLoadsContainer').appendChild(div);
    updateResultsOptions();
    solveSelected();
}
function removePointLoad(i){
    state.pointLoads.splice(i,1);
    document.getElementById('pload-'+i).remove();
    rebuildPointLoads();
    updateResultsOptions();
    solveSelected();
}
function rebuildPointLoads(){
    const c=document.getElementById('pointLoadsContainer');
    c.innerHTML='';
    const arr=state.pointLoads.slice();
    state.pointLoads=[];
    arr.forEach(l=>addPointLoad(l.P,l.x,l.case));
}

function addLineLoad(w=5,start=0,end=1,lc='LC1'){
    const idx=state.lineLoads.length;
    state.lineLoads.push({w,start,end,case:lc});
    const div=document.createElement('div');
    div.className='input-row';
    div.innerHTML=`<label>Line ${idx+1} (w kN/m,start,end,case):</label>`+
    `<input type='number' value='${(w/1000)}' step='0.1' onchange='state.lineLoads[${idx}].w=parseFloat(this.value)*1000; solveSelected();'/>`+
    `<input type='number' value='${start}' step='0.1' onchange='state.lineLoads[${idx}].start=parseFloat(this.value); solveSelected();'/>`+
    `<input type='number' value='${end}' step='0.1' onchange='state.lineLoads[${idx}].end=parseFloat(this.value); solveSelected();'/>`+
    `<input type='text' value='${lc}' onchange='state.lineLoads[${idx}].case=this.value; updateResultsOptions(); solveSelected();'/>`+
    `<button onclick='removeLineLoad(${idx})'>Remove</button>`;
    div.id=`lload-${idx}`;
    document.getElementById('lineLoadsContainer').appendChild(div);
    updateResultsOptions();
    solveSelected();
}
function removeLineLoad(i){
    state.lineLoads.splice(i,1);
    document.getElementById('lload-'+i).remove();
    rebuildLineLoads();
    updateResultsOptions();
    solveSelected();
}
function rebuildLineLoads(){
    const c=document.getElementById('lineLoadsContainer');
    c.innerHTML='';
    const arr=state.lineLoads.slice();
    state.lineLoads=[];
    arr.forEach(l=>{
        if(l.autoSW){
            // preserve automatically generated self weight load
            state.lineLoads.push({w:l.w,start:l.start,end:l.end,case:'SW',autoSW:true});
            const div=document.createElement('div');
            div.className='input-row';
            div.id='lload-sw';
            div.innerHTML=`<label>Line SW (w kN/m,start,end,case):</label>`+
                `<input type='number' value='${(l.w/1000).toFixed(3)}' step='0.001' readonly />`+
                `<input type='number' value='${l.start}' step='0.1' readonly />`+
                `<input type='number' value='${l.end}' step='0.1' readonly />`+
                `<input type='text' value='SW' readonly />`;
            c.appendChild(div);
        } else {
            addLineLoad(l.w,l.start,l.end,l.case);
        }
    });
}

function updateSelfWeightLineLoad(){
    // remove existing auto-generated SW line load
    state.lineLoads = state.lineLoads.filter(l=>!l.autoSW);
    const existing=document.getElementById('lload-sw');
    if(existing) existing.remove();

    if(!state.includeSelfWeight || !state.section) {
        updateResultsOptions();
        return;
    }
    const cs=crossSections[state.section];
    if(!cs) { updateResultsOptions(); return; }
    const w=(cs.gk_kg_per_m*9.81); // N/m
    const len=state.spans.reduce((a,s)=>a+(typeof s==='number'?s:s.length),0);
    state.lineLoads.push({w,start:0,end:len,case:'SW',autoSW:true});
    const div=document.createElement('div');
    div.className='input-row';
    div.id='lload-sw';
    div.innerHTML=`<label>Line SW (w kN/m,start,end,case):</label>`+
        `<input type='number' value='${(w/1000).toFixed(3)}' step='0.001' readonly />`+
        `<input type='number' value='0' step='0.1' readonly />`+
        `<input type='number' value='${len}' step='0.1' readonly />`+
        `<input type='text' value='SW' readonly />`;
    document.getElementById('lineLoadsContainer').appendChild(div);
    updateResultsOptions();
}

function parseFactors(str){
    const obj={};
    str.split(',').forEach(p=>{
        const [n,v]=p.split(':');
        if(n&&v) obj[n.trim()]=parseFloat(v);
    });
    return obj;
}

function addCombination(name=`Comb${state.loadCombinations.length+1}`,factorsStr='LC1:1'){
    const idx=state.loadCombinations.length;
    state.loadCombinations.push({name,factors:parseFactors(factorsStr)});
    const div=document.createElement('div');
    div.className='input-row';
    div.innerHTML=`<input type='text' value='${name}' onchange='state.loadCombinations[${idx}].name=this.value; updateResultsOptions();'/>`+
    `<input type='text' value='${factorsStr}' onchange='state.loadCombinations[${idx}].factors=parseFactors(this.value); solveSelected();'/>`+
    `<button onclick='removeCombination(${idx})'>Remove</button>`;
    div.id=`comb-${idx}`;
    document.getElementById('combContainer').appendChild(div);
    updateResultsOptions();
    solveSelected();
}

function removeCombination(i){
    state.loadCombinations.splice(i,1);
    document.getElementById('comb-'+i).remove();
    rebuildCombinations();
    updateResultsOptions();
    solveSelected();
}

function rebuildCombinations(){
    const c=document.getElementById('combContainer');
    const arr=state.loadCombinations.slice();
    c.innerHTML='';
    state.loadCombinations=[];
    arr.forEach(comb=>addCombination(comb.name,Object.entries(comb.factors).map(([k,v])=>`${k}:${v}`).join(',')));
}

function getLoadsForSelected(){
    const sel = (this && this.selected) || state.selected;
    if(sel.type==='case'){
        const name=sel.name;
        const pl=state.pointLoads.filter(l=>l.case===name);
        const ll=state.lineLoads.filter(l=>l.case===name);
        return {pointLoads:pl, lineLoads:ll};
    }
    if(sel.type==='comb'){
        const comb=state.loadCombinations[sel.index];
        const pl=[],ll=[];
        if(comb){
            Object.entries(comb.factors).forEach(([cn,f])=>{
                state.pointLoads.filter(l=>l.case===cn).forEach(l=>pl.push({P:l.P*f,x:l.x}));
                state.lineLoads.filter(l=>l.case===cn).forEach(l=>ll.push({w:l.w*f,start:l.start,end:l.end}));
            });
        }
        return {pointLoads:pl,lineLoads:ll};
    }
    return {pointLoads:[],lineLoads:[]};
}

function updateResultsOptions(){
    const sel=document.getElementById('resultsSelect');
    const prev=sel.value;
    sel.innerHTML='';
    const cases=new Set();
    state.pointLoads.forEach(l=>cases.add(l.case||'LC1'));
    state.lineLoads.forEach(l=>cases.add(l.case||'LC1'));
    Array.from(cases).sort((a,b)=>a.localeCompare(b,undefined,{numeric:true})).forEach(cn=>{
        const opt=document.createElement('option');
        opt.value=`case:${cn}`; opt.textContent=`Case ${cn}`;
        sel.appendChild(opt);
    });
    state.loadCombinations
        .map((c,i)=>({c,i}))
        .sort((a,b)=>a.c.name.localeCompare(b.c.name,undefined,{numeric:true}))
        .forEach(({c,i})=>{
        const opt=document.createElement('option');
        opt.value=`comb:${i}`; opt.textContent=`Comb ${c.name}`;
        sel.appendChild(opt);
    });
    if(state.loadCombinations.length>0){
        const opt=document.createElement('option');
        opt.value='envelope'; opt.textContent='Envelope';
        sel.appendChild(opt);
    }
    sel.value=prev||sel.options[0]?.value;
    if(!sel.value && sel.options.length>0) sel.selectedIndex=0;
    const val=sel.value||'';
    if(val.startsWith('case:')) state.selected={type:'case',name:val.slice(5)};
    else if(val.startsWith('comb:')) state.selected={type:'comb',index:parseInt(val.slice(5))};
    else state.selected={type:'envelope'};
    updateSelectedText();
}

function updateSelectedText(){
    let txt='Envelope';
    if(state.selected.type==='case') txt='Load case '+state.selected.name;
    else if(state.selected.type==='comb') txt='Combination '+(state.loadCombinations[state.selected.index]?.name||'');
    document.getElementById('selectedDisplay').textContent='Showing results for: '+txt;
}

document.getElementById('addSpanBtn').onclick=()=>addSpan();
document.getElementById('addPointLoadBtn').onclick=()=>addPointLoad();
document.getElementById('addLineLoadBtn').onclick=()=>addLineLoad();
document.getElementById('addCombBtn').onclick=()=>addCombination();
document.getElementById('resultsSelect').onchange=function(){
    updateResultsOptions();
    solveSelected();
};
document.getElementById('sectionSelect').onchange=function(){
    const name=this.value;
    state.section=name;
    if(crossSections[name]){
        state.I=crossSections[name].Iz_m4;
        document.getElementById('inertiaInput').value=state.I;
        updateSectionProps(name);
    }
    updateSelfWeightLineLoad();
    solveSelected();
};
document.getElementById('inertiaInput').onchange=function(){
    state.I=parseFloat(this.value);
    solveSelected();
};
document.getElementById('selfWeightToggle').onchange=function(){
    state.includeSelfWeight=this.checked;
    updateSelfWeightLineLoad();
    updateResultsOptions();
    solveSelected();
};
document.getElementById('leftSupportToggle').onchange=function(){
    state.leftSupport=this.checked;
    solveSelected();
};
document.getElementById('rightSupportToggle').onchange=function(){
    state.rightSupport=this.checked;
    solveSelected();
};

document.getElementById('inertiaInput').value = state.I;
document.getElementById('selfWeightToggle').checked = state.includeSelfWeight;
document.getElementById('leftSupportToggle').checked = state.leftSupport;
document.getElementById('rightSupportToggle').checked = state.rightSupport;

document.getElementById('maxNodeDist').onchange=function(){
    state.maxNodeDist=parseFloat(this.value);
    solveSelected();
};
document.getElementById('exportBtn').onclick=function(){
    window.print();
};

// FEM Solver
function solveSelected(){
    updateResultsOptions();
    if(state.selected.type==='envelope'){
        if(state.loadCombinations.length===0) return;
        let minS,maxS,minM,maxM,minD,maxD,xs,nodes;
        state.loadCombinations.forEach((comb,i)=>{
            const loads=getLoadsForSelected.call({selected:{type:'comb',index:i}});
            const res=computeResults({...state,pointLoads:loads.pointLoads,lineLoads:loads.lineLoads});
            const diagRaw=computeDiagrams({...state,pointLoads:loads.pointLoads,lineLoads:loads.lineLoads},res.nodes,res.reactions);
            const shearVals=diagRaw.shearVals.map(v=>-v);
            const momentVals=diagRaw.momentVals.map(v=>-v);
            const def=res.nodes.map((_,idx)=>res.displacements[2*idx]*1000);
            if(!xs){xs=diagRaw.xs; nodes=res.nodes; minS=shearVals.slice(); maxS=shearVals.slice(); minM=momentVals.slice(); maxM=momentVals.slice(); minD=def.slice(); maxD=def.slice();}
            else{
                shearVals.forEach((v,j)=>{if(v<minS[j]) minS[j]=v; if(v>maxS[j]) maxS[j]=v;});
                momentVals.forEach((v,j)=>{if(v<minM[j]) minM[j]=v; if(v>maxM[j]) maxM[j]=v;});
                def.forEach((v,j)=>{if(v<minD[j]) minD[j]=v; if(v>maxD[j]) maxD[j]=v;});
            }
        });
        updateChart(shearChart,xs,[minS,maxS],'Shear');
        updateChart(momentChart,xs,[minM,maxM],'Moment');
        plotDeflection(nodes,[minD,maxD]);
        document.getElementById("reactionsOutput").textContent='Envelope shown';
        const minShear=(Math.min(...minS)/1000).toFixed(2);
        const maxShear=(Math.max(...maxS)/1000).toFixed(2);
        const minMoment=(Math.min(...minM)/1000).toFixed(2);
        const maxMoment=(Math.max(...maxM)/1000).toFixed(2);
        const minDef=Math.min(...minD).toFixed(2);
        const maxDef=Math.max(...maxD).toFixed(2);
        const txt=`Shear: ${minShear} kN to ${maxShear} kN\n`+
                   `Moment: ${minMoment} kNm to ${maxMoment} kNm\n`+
                   `Deflection: ${minDef} mm to ${maxDef} mm`;
        document.getElementById("summaryOutput").textContent=txt;
        return;
    }
    const loads=getLoadsForSelected();
    const results = computeResults({...state,pointLoads:loads.pointLoads,lineLoads:loads.lineLoads});
    if(!results) return;
    const {nodes,reactions,displacements,supportIndices} = results;
    const diag = plotDiagrams(nodes,reactions,loads,supportIndices);
    plotDeflection(nodes,displacements);
    showReactions(nodes,reactions,supportIndices);
    showSummary(diag,displacements,nodes);
}


function showReactions(nodes,reactions,supportIndices){
    const out=[];
    supportIndices.forEach((idx,i)=>{
        const R=reactions[2*idx]/1000;
        out.push(`Support ${i+1} reaction: ${R.toFixed(2)} kN`);
    });
    document.getElementById("reactionsOutput").textContent=out.join("\n");
}
function showSummary(diag,disp,nodes){
    const minShear=(Math.min(...diag.shearVals)/1000).toFixed(2);
    const maxShear=(Math.max(...diag.shearVals)/1000).toFixed(2);
    const minMoment=(Math.min(...diag.momentVals)/1000).toFixed(2);
    const maxMoment=(Math.max(...diag.momentVals)/1000).toFixed(2);
    const def=nodes.map((_,i)=>-disp[2*i]);
    const minDef=(Math.min(...def)*1000).toFixed(2);
    const maxDef=(Math.max(...def)*1000).toFixed(2);
    const txt=`Shear: ${minShear} kN to ${maxShear} kN\n`+
               `Moment: ${minMoment} kNm to ${maxMoment} kNm\n`+
               `Deflection: ${minDef} mm to ${maxDef} mm`;
    document.getElementById("summaryOutput").textContent=txt;
}


function plotDiagrams(nodes,reactions,loads,supportIndices){
    const events=[];
    const totalLength=nodes[nodes.length-1];
    for(let i=0;i<nodes.length;i++) events.push({x:nodes[i],P:reactions[2*i]});
    (loads.pointLoads||[]).forEach(p=>events.push({x:p.x,P:p.P}));
    (loads.lineLoads||[]).forEach(l=>events.push({x:l.start,w:l.w,start:true}));
    (loads.lineLoads||[]).forEach(l=>events.push({x:l.end,w:l.w,end:true}));
    events.sort((a,b)=>a.x-b.x);

    let shear=0, moment=0;
    const xs=[0],shearVals=[0],momentVals=[0];
    const loadXs=[0],loadVals=[0];
    let activeWs=[];
    for(let i=0;i<events.length;i++){
        const e=events[i];
        const dx=e.x-xs[xs.length-1];
        const wTotal=activeWs.reduce((a,b)=>a+b,0);
        const shearBefore=shear;
        shear-=wTotal*dx;
        moment+=shearBefore*dx - 0.5*wTotal*dx*dx;
        xs.push(e.x); shearVals.push(shear); momentVals.push(moment);

        loadXs.push(e.x); loadVals.push(wTotal);

        if(e.P){
            shear-=e.P;
            xs.push(e.x); shearVals.push(shear); momentVals.push(moment);
        }
        if(e.start){activeWs.push(e.w);}
        if(e.end){
            const idx=activeWs.indexOf(e.w);
            if(idx>-1) activeWs.splice(idx,1);
        }
    }
    const lastX=xs[xs.length-1];
    const lastL=loadXs[loadXs.length-1];
    if(lastX<totalLength){
        const dx=totalLength-lastX;
        const wTotal=activeWs.reduce((a,b)=>a+b,0);
        const shearBefore=shear;
        shear-=wTotal*dx;
        moment+=shearBefore*dx -0.5*wTotal*dx*dx;
        xs.push(totalLength); shearVals.push(shear); momentVals.push(moment);
    }
    if(lastL<totalLength){
        loadXs.push(totalLength); loadVals.push(activeWs.reduce((a,b)=>a+b,0));
    }
    // flip sign so downward loads give sagging moments and downward shear
    const shearAdj=shearVals.map(v=>-v);
    const momentAdj=momentVals.map(v=>-v);
    const pointData=(loads.pointLoads||[]).map(p=>({x:p.x,y:p.P}));
    const reactionsScatter=(supportIndices||[]).map(idx=>({x:nodes[idx],y:reactions[2*idx]}));
    updateChart(loadChart,loadXs,loadVals,'Loads',pointData,reactionsScatter);
    updateChart(shearChart,xs,shearAdj,'Shear');
    updateChart(momentChart,xs,momentAdj,'Moment');
    return {xs,shearVals:shearAdj, momentVals:momentAdj};
}

function plotDeflection(nodes,U){
    const xs=nodes.slice();
    if(Array.isArray(U[0])){
        const neg=U.map(arr=>arr.map(v=>-v));
        updateChart(deflectionChart,xs,neg,'Deflection');
    } else {
        const def=[];
        for(let i=0;i<xs.length;i++) def.push(-U[2*i]*1000);
        updateChart(deflectionChart,xs,def,'Deflection');
    }
}

let shearChart=null,momentChart=null,deflectionChart=null,loadChart=null;
const reactionPlugin={
    id:'reactionPlugin',
    afterDatasetsDraw(chart,args,opts){
        const reactions=chart.options.reactions||[];
        if(reactions.length===0) return;
        const ctx=chart.ctx;
        ctx.save();
        ctx.fillStyle='black';
        ctx.font='12px sans-serif';
        reactions.forEach(r=>{
            const xPix=chart.scales.x.getPixelForValue(r.x);
            const yPix=chart.scales.y.getPixelForValue(0);
            ctx.fillText((r.y/1000).toFixed(2)+' kN',xPix+5,yPix-5);
        });
        ctx.restore();
    }
};
if(window.Chart) Chart.register(reactionPlugin);

function updateChart(chart,x,y,label,scatter,reactions){
    const isEnvelope=Array.isArray(y[0]);
    let unitLabel='';
    if(label==='Shear' || label==='Moment'){
        const scaleData=arr=>arr.map(v=>v/1000);
        if(isEnvelope){
            y=[scaleData(y[0]),scaleData(y[1])];
        } else {
            y=scaleData(y);
        }
        unitLabel=label==='Shear'?' (kN)':' (kNm)';
    }
    if(chart){
        chart.destroy();
        chart=null;
        if(label==='Shear') shearChart=null;
        if(label==='Moment') momentChart=null;
        if(label==='Deflection') deflectionChart=null;
        if(label==='Loads') loadChart=null;
    }
    const ctx=document.getElementById(label.toLowerCase()+'Chart').getContext('2d');
    let datasets;
    if(isEnvelope){
        const dmin=x.map((v,i)=>({x:v,y:y[0][i]}));
        const dmax=x.map((v,i)=>({x:v,y:y[1][i]}));
        datasets=[{label:label+' min',data:dmin,fill:false,borderColor:'blue',backgroundColor:'rgba(0,0,255,0.2)',showLine:true},
                  {label:label+' max',data:dmax,fill:'-1',borderColor:'green',backgroundColor:'rgba(0,255,0,0.2)',showLine:true}];
    } else {
        const xyData=x.map((v,i)=>({x:v,y:y[i]}));
        datasets=[{label:label,data:xyData,fill:true,borderColor:'blue',backgroundColor:'rgba(0,0,255,0.2)',showLine:true}];
    }
    if(scatter){
        datasets.push({type:'scatter',label:'P',data:scatter,borderColor:'red',backgroundColor:'red',showLine:false});
    }
    const zeroLine=x.map(v=>({x:v,y:0}));
    datasets.unshift({label:'Beam',data:zeroLine,fill:false,borderColor:'black',borderWidth:3,pointRadius:0,showLine:true});
    if(reactions){
        datasets.push({type:'scatter',label:'R',data:reactions,borderColor:'orange',backgroundColor:'orange',showLine:false});
    }
    const yTitle=label+unitLabel;
    const newChart=new Chart(ctx,{type:'line',data:{datasets},options:{scales:{x:{type:'linear',title:{display:true,text:'x'}},y:{title:{display:true,text:yTitle}}},reactions:reactions||[]}});
    if(label==='Shear') shearChart=newChart;
    if(label==='Moment') momentChart=newChart;
    if(label==='Deflection') deflectionChart=newChart;
    if(label==='Loads') loadChart=newChart;
}

addSpan(10);
addLineLoad(5000,0,10);
solveSelected();
    </script>
</body>
</html>
